---
layout: post
title: ìœ¤ì„±ìš°ì˜ ì—´í˜ˆ ìžë£Œêµ¬ì¡° Chap11-íƒìƒ‰(Search) 1
image:
  path: /assets/img/datastruct/main.jpg
description: >
  ìœ¤ì„±ìš°ì˜ ì—´í˜ˆ ìžë£Œêµ¬ì¡° Chap11-íƒìƒ‰(Search) 1
sitemap: false
hide_last_modified: true
---

ðŸ“˜YES24
[![yes24](/assets/img/datastruct/main.png)](http://www.yes24.com/Product/Goods/6214396)

# 1. íƒìƒ‰ì˜ ì´í•´ì™€ ë³´ê°„ íƒìƒ‰

## íƒìƒ‰

- ë°ì´í„°ë¥¼ ì°¾ëŠ” ë°©ë²•

## ë³´ê°„ íƒìƒ‰

- ì´ì§„ íƒìƒ‰ì€ ì¤‘ì•™ì— ìœ„ì¹˜í•œ ë°ì´í„°ë¥¼ íƒìƒ‰í•œ í›„, ì´ë¥¼ ê¸°ì¤€ìœ¼ë¡œ íƒìƒ‰ëŒ€ìƒì„ ë°˜ì”© ì¤„ì—¬ë‚˜ê°€ë©´ì„œ íƒìƒ‰ì„ ì§„í–‰í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜
- ë³´ê°„ íƒìƒ‰ì€ ì´ì§„ íƒìƒ‰ì˜ ë¹„íš¨ìœ¨ì„±ì„ ê°œì„ ì‹œí‚¨ ì•Œê³ ë¦¬ì¦˜
- íƒìƒ‰ëŒ€ìƒì´ ìžˆì„ê³³ ê°™ì€ë° ë¶€í„° íƒìƒ‰ ì‹œìž‘

### ì´ì§„íƒìƒ‰

![Untitled](/assets/img/datastruct/11/11-1.png)

### ë³´ê°„íƒìƒ‰

- ë°ì´í„°ê°€ ìžˆì„ê²ƒ ê°™ì€ê³³ì„ íƒìƒ‰

![Untitled](/assets/img/datastruct/11/11-2.png)

- ë°ì´í„°ì˜ ê°’ê³¼ ê·¸ ë°ì´í„°ê°€ ì €ìž¥ëœ ìœ„ì¹˜ì˜ ì¸ë±ìŠ¤ ê°’ì´ ë¹„ë¡€í•œë‹¤ê³  ê°€ì •í•œ ë¹„ë¡€ì‹
  $A:Q=(high-low):(s-low)$
- sì— ëŒ€í•œ ë¹„ë¡€ì‹
  $s=\frac{Q}{A}(high-low)+low$
- arr[s]ë¥¼ xë¼í•˜ê³  Qì™€ Aì— arrëŒ€ìž…
  $s=\frac{x-arr[low]}{arr[high]-arr[low]}(high-low)+low$

### ë³´ê°„íƒìƒ‰ì˜ ë‹¨ì 

- ì˜¤ì°¨ìœ¨ì„ ìµœì†Œí™”í•˜ê¸° ìœ„í•´ì„œ ì •ìˆ˜í˜• ë‚˜ëˆ—ì…ˆì´ ì•„ë‹Œ ì‹¤ìˆ˜í˜• ë‚˜ëˆ—ì…ˆì„ ì§„í–‰í•œë‹¤

```jsx
function iSearch(arr, first, last, target) {
  let mid;

  if (arr[first] > target || arr[last] < target) {
    return -1;
  }

  mid =
    Math.floor((target - arr[first]) / (arr[last] - arr[first])) *
      (last - first) +
    first;

  if (arr[mid] == target) {
    return mid;
  } else if (target < arr[mid]) {
    return iSearch(arr, first, mid - 1, target);
  } else {
    return iSearch(arr, mid + 1, last, target);
  }
}

let arr = [1, 3, 5, 7, 9];
let idx;

idx = iSearch(arr, 0, arr.length - 1, 7);
console.log(idx);
idx = iSearch(arr, 0, arr.length - 1, 10);
console.log(idx);
idx = iSearch(arr, 0, arr.length - 1, 2);
console.log(idx);
```

```jsx
function interpolationSearch(arr, key) {
  const length = arr.length - 1;
  let low = 0;
  let high = length;
  let position = -1;
  let delta = -1;

  // Because the array is sorted the key must be between low and high
  while (low <= high && key >= arr[low] && key <= arr[high]) {
    delta = (key - arr[low]) / (arr[high] - arr[low]);
    position = low + Math.floor((high - low) * delta);

    // Target found return its position
    if (arr[position] === key) {
      return position;
    }

    // If the key is larger then it is in the upper part of the array
    if (arr[position] < key) {
      low = position + 1;
      // If the key is smaller then it is in the lower part of the array
    } else {
      high = position - 1;
    }
  }

  return -1;
}
```

## ì‹œê°„ ë³µìž¡ë„

- Best case : O(1)
- Worst case : O(n)
- ë°ì´í„°ê°€ ê· ì¼í•˜ê²Œ ë¶„í¬í•œ ê²½ìš° O(log(log(n))

# ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬

## ì¡°ê±´

- ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬ì˜ ë…¸ë“œì— ì €ìž¥ëœ í‚¤ëŠ” ìœ ì¼
- ë£¨íŠ¸ ë…¸ë“œì˜ í‚¤ê°€ ì™¼ìª½ ì„œë¸Œ íŠ¸ë¦¬ë¥¼ êµ¬ì„±í•˜ëŠ” ì–´ë– í•œ ë…¸ë“œì˜ í‚¤ë³´ë‹¤ í¬ë‹¤
- ë£¨íŠ¸ ë…¸ë“œì˜ í‚¤ê°€ ì˜¤ë¥¸ìª½ ì„œë¸Œ íŠ¸ë¦¬ë¥¼ êµ¬ì„±í•˜ëŠ” ì–´ë– í•œ ë…¸ë“œì˜ í‚¤ë³´ë‹¤ ìž‘ë‹¤
- ì™¼ìª½ê³¼ ì˜¤ë¥¸ìª½ ì„œë¸Œ íŠ¸ë¦¬ë„ ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬ë‹¤

![Untitled](/assets/img/datastruct/11/11-3.png)

### ì™¼ìª½ ìžì‹ ë…¸ë“œì˜ í‚¤ < ë¶€ëª¨ ë…¸ë“œì˜ í‚¤ < ì˜¤ë¥¸ìª½ ìžì‹ ë…¸ë“œì˜ í‚¤

## ì‚½ìž…ê³¼ íƒìƒ‰

![Untitled](/assets/img/datastruct/11/11-4.png)

## ì‚­ì œ

### ì‚­ì œ ìƒí™©

- ìƒí™©1 : ì‚­ì œí•  ë…¸ë“œê°€ ë‹¨ë§ ë…¸ë“œì¸ ê²½ìš°
- ìƒí™©2 : ì‚­ì œí•  ë…¸ë“œê°€ í•˜ë‚˜ì˜ ìžì‹ ë…¸ë“œë¥¼ ê°–ëŠ” ê²½ìš°
- ìƒí™©3 : ì‚­ì œí•  ë…¸ë“œê°€ ë‘ ê°œì˜ ìžì‹ ë…¸ë“œë¥¼ ê°–ëŠ” ê²½ìš°

```jsx
/* Binary Search Tree!!
 *
 * Nodes that will go on the Binary Tree.
 * They consist of the data in them, the node to the left, the node
 * to the right, and the parent from which they came from.
 *
 * A binary tree is a data structure in which an element
 * has two successors(children). The left child is usually
 * smaller than the parent, and the right child is usually
 * bigger.
 */

// class Node
const Node = (function Node() {
  // Node in the tree
  function Node(val) {
    this.value = val;
    this.left = null;
    this.right = null;
  }

  // Search the tree for a value
  Node.prototype.search = function (val) {
    if (this.value === val) {
      return this;
    } else if (val < this.value && this.left !== null) {
      return this.left.search(val);
    } else if (val > this.value && this.right !== null) {
      return this.right.search(val);
    }
    return null;
  };

  // Visit a node
  Node.prototype.visit = function (output = (value) => console.log(value)) {
    // Recursively go left
    if (this.left !== null) {
      this.left.visit();
    }
    // Print out value
    output(this.value);
    // Recursively go right
    if (this.right !== null) {
      this.right.visit();
    }
  };

  // Add a node
  Node.prototype.addNode = function (n) {
    if (n.value < this.value) {
      if (this.left === null) {
        this.left = n;
      } else {
        this.left.addNode(n);
      }
    } else if (n.value > this.value) {
      if (this.right === null) {
        this.right = n;
      } else {
        this.right.addNode(n);
      }
    }
  };

  // remove a node
  Node.prototype.removeNode = function (val) {
    if (val === this.value) {
      if (!this.left && !this.right) {
        return null;
      } else {
        if (this.left) {
          const leftMax = maxVal(this.left);
          this.value = leftMax;
          this.left = this.left.removeNode(leftMax);
        } else {
          const rightMin = minVal(this.right);
          this.value = rightMin;
          this.right = this.right.removeNode(rightMin);
        }
      }
    } else if (val < this.value) {
      this.left = this.left && this.left.removeNode(val);
    } else if (val > this.value) {
      this.right = this.right && this.right.removeNode(val);
    }
    return this;
  };

  // find maximum value in the tree
  const maxVal = function (node) {
    if (!node.right) {
      return node.value;
    }
    return maxVal(node.right);
  };

  // find minimum value in the tree
  const minVal = function (node) {
    if (!node.left) {
      return node.value;
    }
    return minVal(node.left);
  };
  // returns the constructor
  return Node;
})();

// class Tree
const Tree = (function () {
  function Tree() {
    // Just store the root
    this.root = null;
  }

  // Inorder traversal
  Tree.prototype.traverse = function () {
    if (!this.root) {
      // No nodes are there in the tree till now
      return;
    }
    this.root.visit();
  };

  // Start by searching the root
  Tree.prototype.search = function (val) {
    const found = this.root.search(val);
    if (found !== null) {
      return found.value;
    }
    // not found
    return null;
  };

  // Add a new value to the tree
  Tree.prototype.addValue = function (val) {
    const n = new Node(val);
    if (this.root === null) {
      this.root = n;
    } else {
      this.root.addNode(n);
    }
  };

  // remove a value from the tree
  Tree.prototype.removeValue = function (val) {
    // remove something if root exists
    this.root = this.root && this.root.removeNode(val);
  };

  // returns the constructor
  return Tree;
})();
```
